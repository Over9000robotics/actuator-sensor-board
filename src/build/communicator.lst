   1               		.file	"communicator.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               	.global	transmit_byte
  13               	transmit_byte:
  14               	.LFB7:
  15               		.file 1 "communicator.c"
   1:communicator.c **** #include <avr/io.h>
   2:communicator.c **** #include <avr/interrupt.h>
   3:communicator.c **** #include <stdint.h>
   4:communicator.c **** #include <util/delay.h>
   5:communicator.c **** 
   6:communicator.c **** #include "communicator.h"
   7:communicator.c **** #include "sensor.h"
   8:communicator.c **** #include "actuator.h"
   9:communicator.c **** #include "usart0.h"
  10:communicator.c **** #include "spi.h"
  11:communicator.c **** 
  12:communicator.c **** static uint8_t const selected_protocol = UART;
  13:communicator.c **** 
  14:communicator.c **** void transmit_byte(uint8_t byte)
  15:communicator.c **** {
  16               		.loc 1 15 0
  17               		.cfi_startproc
  18               	.LVL0:
  19               	/* prologue: function */
  20               	/* frame size = 0 */
  21               	/* stack size = 0 */
  22               	.L__stack_usage = 0
  16:communicator.c **** 	if(selected_protocol == UART)
  17:communicator.c **** 	{
  18:communicator.c **** 		USART0_transmit(byte);
  23               		.loc 1 18 0
  24 0000 0C94 0000 		jmp USART0_transmit
  25               	.LVL1:
  26               		.cfi_endproc
  27               	.LFE7:
  29               	.global	read_byte
  31               	read_byte:
  32               	.LFB8:
  19:communicator.c **** 	}
  20:communicator.c **** 	else if(selected_protocol == SPI)
  21:communicator.c **** 	{
  22:communicator.c **** 		SPI_transmit(byte);
  23:communicator.c **** 	}
  24:communicator.c **** }
  25:communicator.c **** 
  26:communicator.c **** uint8_t read_byte(void)
  27:communicator.c **** {
  33               		.loc 1 27 0
  34               		.cfi_startproc
  35               	/* prologue: function */
  36               	/* frame size = 0 */
  37               	/* stack size = 0 */
  38               	.L__stack_usage = 0
  28:communicator.c **** 	uint8_t byte;
  29:communicator.c **** 	
  30:communicator.c **** 	if(selected_protocol == UART)
  31:communicator.c **** 	{
  32:communicator.c **** 		byte = USART0_receive();
  39               		.loc 1 32 0
  40 0004 0C94 0000 		jmp USART0_receive
  41               	.LVL2:
  42               		.cfi_endproc
  43               	.LFE8:
  45               	.global	read_packet
  47               	read_packet:
  48               	.LFB9:
  33:communicator.c **** 	}
  34:communicator.c **** 	
  35:communicator.c **** 	else if(selected_protocol == SPI)
  36:communicator.c **** 	{
  37:communicator.c **** 		byte = SPI_receive();
  38:communicator.c **** 	}
  39:communicator.c **** 	
  40:communicator.c **** 	return byte;
  41:communicator.c **** }
  42:communicator.c **** 
  43:communicator.c **** void read_packet(void)
  44:communicator.c **** {
  49               		.loc 1 44 0
  50               		.cfi_startproc
  51 0008 CF93      		push r28
  52               	.LCFI0:
  53               		.cfi_def_cfa_offset 3
  54               		.cfi_offset 28, -2
  55               	/* prologue: function */
  56               	/* frame size = 0 */
  57               	/* stack size = 1 */
  58               	.L__stack_usage = 1
  59               	.LBB14:
  60               	.LBB15:
  32:communicator.c **** 	}
  61               		.loc 1 32 0
  62 000a 0E94 0000 		call USART0_receive
  63               	.LVL3:
  64               	.LBE15:
  65               	.LBE14:
  45:communicator.c **** 	uint8_t incoming_byte = read_byte();
  46:communicator.c **** 
  47:communicator.c **** 	switch(incoming_byte)
  66               		.loc 1 47 0
  67 000e 8234      		cpi r24,lo8(66)
  68 0010 01F0      		breq .L5
  69 0012 8335      		cpi r24,lo8(83)
  70 0014 01F0      		breq .L6
  71 0016 8134      		cpi r24,lo8(65)
  72 0018 01F4      		brne .L8
  73               	.LVL4:
  74               	.LBB16:
  75               	.LBB17:
  76               	.LBB18:
  32:communicator.c **** 	}
  77               		.loc 1 32 0
  78 001a 0E94 0000 		call USART0_receive
  79               	.LVL5:
  80 001e C82F      		mov r28,r24
  81               	.LVL6:
  82               	.LBE18:
  83               	.LBE17:
  84               	.LBB19:
  85               	.LBB20:
  86 0020 0E94 0000 		call USART0_receive
  87               	.LVL7:
  88               	.LBE20:
  89               	.LBE19:
  48:communicator.c **** 	{
  49:communicator.c **** 		case SENSOR_ASK:
  50:communicator.c **** 		{
  51:communicator.c **** 			send_sensor_status();
  52:communicator.c **** 			break;
  53:communicator.c **** 		}
  54:communicator.c **** 		case BR_SET_SPEED:
  55:communicator.c **** 		{
  56:communicator.c **** 			uint8_t speed = 0;
  57:communicator.c **** 			uint8_t brushless_num = 0;
  58:communicator.c **** 			
  59:communicator.c **** 			brushless_num = read_byte();
  60:communicator.c **** 			speed = read_byte();
  61:communicator.c **** 			
  62:communicator.c **** 			brushless_set_speed(brushless_num, speed);
  63:communicator.c **** 			break;
  64:communicator.c **** 		}
  65:communicator.c **** 		
  66:communicator.c **** 			case SERVO_SET_ANGLE:
  67:communicator.c **** 		{
  68:communicator.c **** 			uint8_t angle = 0;
  69:communicator.c **** 			uint8_t servo_num = 0;
  70:communicator.c **** 			
  71:communicator.c **** 			servo_num = read_byte();
  72:communicator.c **** 			angle = read_byte();
  73:communicator.c **** 	
  74:communicator.c **** 			servo_set_position(servo_num, angle);
  90               		.loc 1 74 0
  91 0024 682F      		mov r22,r24
  92 0026 8C2F      		mov r24,r28
  93               	.LVL8:
  94               	/* epilogue start */
  95               	.LBE16:
  75:communicator.c **** 			break;
  76:communicator.c **** 		}
  77:communicator.c **** 		
  78:communicator.c **** 		default:
  79:communicator.c **** 		{
  80:communicator.c **** 			
  81:communicator.c **** 			break;
  82:communicator.c **** 		}
  83:communicator.c **** 	}
  84:communicator.c **** }
  96               		.loc 1 84 0
  97 0028 CF91      		pop r28
  98               	.LVL9:
  99               	.LBB21:
  74:communicator.c **** 			break;
 100               		.loc 1 74 0
 101 002a 0C94 0000 		jmp servo_set_position
 102               	.LVL10:
 103               	.L6:
 104               	/* epilogue start */
 105               	.LBE21:
 106               		.loc 1 84 0
 107 002e CF91      		pop r28
  51:communicator.c **** 			break;
 108               		.loc 1 51 0
 109 0030 0C94 0000 		jmp send_sensor_status
 110               	.LVL11:
 111               	.L5:
 112               	.LBB22:
 113               	.LBB23:
 114               	.LBB24:
  32:communicator.c **** 	}
 115               		.loc 1 32 0
 116 0034 0E94 0000 		call USART0_receive
 117               	.LVL12:
 118 0038 C82F      		mov r28,r24
 119               	.LVL13:
 120               	.LBE24:
 121               	.LBE23:
 122               	.LBB25:
 123               	.LBB26:
 124 003a 0E94 0000 		call USART0_receive
 125               	.LVL14:
 126               	.LBE26:
 127               	.LBE25:
  62:communicator.c **** 			break;
 128               		.loc 1 62 0
 129 003e 682F      		mov r22,r24
 130 0040 8C2F      		mov r24,r28
 131               	.LVL15:
 132               	/* epilogue start */
 133               	.LBE22:
 134               		.loc 1 84 0
 135 0042 CF91      		pop r28
 136               	.LVL16:
 137               	.LBB27:
  62:communicator.c **** 			break;
 138               		.loc 1 62 0
 139 0044 0C94 0000 		jmp brushless_set_speed
 140               	.LVL17:
 141               	.L8:
 142               	/* epilogue start */
 143               	.LBE27:
 144               		.loc 1 84 0
 145 0048 CF91      		pop r28
 146 004a 0895      		ret
 147               		.cfi_endproc
 148               	.LFE9:
 150               	.Letext0:
 151               		.file 2 "/usr/lib/avr/include/stdint.h"
 152               		.file 3 "usart0.h"
 153               		.file 4 "actuator.h"
 154               		.file 5 "sensor.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 communicator.c
     /tmp/ccaeyBfr.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccaeyBfr.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccaeyBfr.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccaeyBfr.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccaeyBfr.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccaeyBfr.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccaeyBfr.s:13     .text:0000000000000000 transmit_byte
     /tmp/ccaeyBfr.s:31     .text:0000000000000004 read_byte
     /tmp/ccaeyBfr.s:47     .text:0000000000000008 read_packet

UNDEFINED SYMBOLS
USART0_transmit
USART0_receive
servo_set_position
send_sensor_status
brushless_set_speed
