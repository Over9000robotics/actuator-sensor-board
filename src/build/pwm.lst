   1               		.file	"pwm.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               	.global	pbr_pwm_set
  13               	pbr_pwm_set:
  14               	.LFB6:
  15               		.file 1 "pwm.c"
   1:pwm.c         **** //TODO
   2:pwm.c         **** // - Timer2 pwm generating
   3:pwm.c         **** // -  Servo mission  control with RPI
   4:pwm.c         **** 
   5:pwm.c         **** #include <avr/io.h>
   6:pwm.c         **** #include <avr/interrupt.h>
   7:pwm.c         **** #include <stdint.h>
   8:pwm.c         **** #include <util/delay.h>
   9:pwm.c         **** 
  10:pwm.c         **** #include "pwm.h"
  11:pwm.c         **** #include "actuator.h"
  12:pwm.c         **** #include "communicator.h"
  13:pwm.c         **** #include "register.h"
  14:pwm.c         **** 
  15:pwm.c         **** 
  16:pwm.c         **** volatile static uint16_t* servo1 = &OCR1A; //PB2 connector
  17:pwm.c         **** volatile static uint16_t* servo2 = &OCR1B; //PB3 connector
  18:pwm.c         **** volatile static uint16_t* servo3 = &OCR1C; //PB4 connector
  19:pwm.c         **** 
  20:pwm.c         **** /********************************************************************
  21:pwm.c         ****  *  PWM on 8-bit timer2 not implemented								*
  22:pwm.c         ****  * On our robot, there would be three pwm servos					*
  23:pwm.c         ****  * Fourth pwm connector could be universal for some backup systems  *
  24:pwm.c         ****  ********************************************************************/
  25:pwm.c         **** volatile static  uint8_t* servo4 = &OCR2A; //PB1 connector
  26:pwm.c         **** 
  27:pwm.c         **** volatile static uint16_t* head_brushless = &OCR3C;	 //PBR1
  28:pwm.c         **** volatile static uint16_t* second_brushless = &OCR3B; //PBR2
  29:pwm.c         **** 
  30:pwm.c         **** static uint32_t icr3_temp;
  31:pwm.c         **** static uint32_t icr1_temp;
  32:pwm.c         **** 
  33:pwm.c         **** /**
  34:pwm.c         ****  * min -> 1 ms -> pwm = 1000
  35:pwm.c         ****  * max -> 2 ms -> pwm = 2000
  36:pwm.c         ****  * -> offset = 1000
  37:pwm.c         ****  * 0% - 100% will be from 1000 to 2000
  38:pwm.c         **** */
  39:pwm.c         **** void pbr_pwm_set(uint8_t brushless_num, uint8_t procent)
  40:pwm.c         **** {
  16               		.loc 1 40 0
  17               		.cfi_startproc
  18               	.LVL0:
  19               	/* prologue: function */
  20               	/* frame size = 0 */
  21               	/* stack size = 0 */
  22               	.L__stack_usage = 0
  41:pwm.c         **** 	uint32_t pwm_val = 0;
  42:pwm.c         **** 
  43:pwm.c         **** 	if(procent > 100 || procent < 0)
  23               		.loc 1 43 0
  24 0000 6536      		cpi r22,lo8(101)
  25 0002 00F4      		brsh .L1
  44:pwm.c         **** 		return;
  45:pwm.c         **** 
  46:pwm.c         **** 	//pwm_val = (int) ((icr3_temp * procent) / 100); //test -> pwm can be from 0 to max
  47:pwm.c         **** 
  48:pwm.c         **** 	pwm_val = 1000 + procent * (1000 / 100);
  26               		.loc 1 48 0
  27 0004 9AE0      		ldi r25,lo8(10)
  28 0006 699F      		mul r22,r25
  29 0008 B001      		movw r22,r0
  30 000a 1124      		clr __zero_reg__
  31               	.LVL1:
  32 000c 6851      		subi r22,24
  33 000e 7C4F      		sbci r23,-4
  34               	.LVL2:
  49:pwm.c         **** 
  50:pwm.c         **** 	if(brushless_num == BR_HEAD)
  35               		.loc 1 50 0
  36 0010 8130      		cpi r24,lo8(1)
  37 0012 01F4      		brne .L3
  51:pwm.c         **** 	{
  52:pwm.c         **** 		register_16_write(head_brushless, pwm_val);
  38               		.loc 1 52 0
  39 0014 8CE9      		ldi r24,lo8(-100)
  40 0016 90E0      		ldi r25,0
  41               	.LVL3:
  42 0018 00C0      		rjmp .L4
  43               	.LVL4:
  44               	.L3:
  53:pwm.c         **** 	}
  54:pwm.c         **** 
  55:pwm.c         **** 	else if(brushless_num == BR_SECONDARY)
  45               		.loc 1 55 0
  46 001a 8230      		cpi r24,lo8(2)
  47 001c 01F4      		brne .L1
  56:pwm.c         **** 	{
  57:pwm.c         **** 		register_16_write(second_brushless, pwm_val);
  48               		.loc 1 57 0
  49 001e 8AE9      		ldi r24,lo8(-102)
  50 0020 90E0      		ldi r25,0
  51               	.LVL5:
  52               	.L4:
  53 0022 0C94 0000 		jmp register_16_write
  54               	.LVL6:
  55               	.L1:
  56 0026 0895      		ret
  57               		.cfi_endproc
  58               	.LFE6:
  60               	.global	servo_pwm_set
  62               	servo_pwm_set:
  63               	.LFB7:
  58:pwm.c         **** 	}
  59:pwm.c         **** }
  60:pwm.c         **** 
  61:pwm.c         **** /**
  62:pwm.c         ****  * Pusle width -> 20 ms
  63:pwm.c         ****  * Duty cycle -> 0.5 to 2.5 ms
  64:pwm.c         ****  */
  65:pwm.c         **** void servo_pwm_set(int8_t servo_num, uint8_t degrees)
  66:pwm.c         **** {
  64               		.loc 1 66 0
  65               		.cfi_startproc
  66               	.LVL7:
  67               	/* prologue: function */
  68               	/* frame size = 0 */
  69               	/* stack size = 0 */
  70               	.L__stack_usage = 0
  67:pwm.c         **** 	uint32_t pwm_val = 0;
  68:pwm.c         **** 
  69:pwm.c         **** 	//	16-bit pwm timers
  70:pwm.c         **** 	// 500  -> 0.5 ms -> position LEFT
  71:pwm.c         **** 	// 1500 -> 1.5 ms -> position RIGHT
  72:pwm.c         **** 	
  73:pwm.c         **** 	if(servo_num == SERVO1)
  71               		.loc 1 73 0
  72 0028 8130      		cpi r24,lo8(1)
  73 002a 01F4      		brne .L7
  74               	.LVL8:
  74:pwm.c         **** 	{
  75:pwm.c         **** 		pwm_val = SERVO_OCR_MIN + ((uint32_t) degrees * (SERVO_OCR_MAX-SERVO_OCR_MIN)) / 180;
  75               		.loc 1 75 0
  76 002c 262F      		mov r18,r22
  77 002e 30E0      		ldi r19,0
  78 0030 A0ED      		ldi r26,lo8(-48)
  79 0032 B7E0      		ldi r27,lo8(7)
  80 0034 0E94 0000 		call __umulhisi3
  81               	.LVL9:
  82 0038 24EB      		ldi r18,lo8(-76)
  83 003a 30E0      		ldi r19,0
  84 003c 40E0      		ldi r20,0
  85 003e 50E0      		ldi r21,0
  86               	.LVL10:
  87 0040 0E94 0000 		call __udivmodsi4
  88 0044 CA01      		movw r24,r20
  89 0046 B901      		movw r22,r18
  90 0048 6C50      		subi r22,12
  91 004a 7E4F      		sbci r23,-2
  92 004c 8F4F      		sbci r24,-1
  93 004e 9F4F      		sbci r25,-1
  76:pwm.c         **** 		register_16_write(servo1, pwm_val);
  94               		.loc 1 76 0
  95 0050 88E8      		ldi r24,lo8(-120)
  96 0052 90E0      		ldi r25,0
  97               	.LVL11:
  98 0054 00C0      		rjmp .L10
  99               	.LVL12:
 100               	.L7:
  77:pwm.c         **** 	}
  78:pwm.c         **** 	
  79:pwm.c         **** 	else if(servo_num == SERVO2)
 101               		.loc 1 79 0
 102 0056 8230      		cpi r24,lo8(2)
 103 0058 01F4      		brne .L8
 104               	.LVL13:
  80:pwm.c         **** 	{
  81:pwm.c         **** 		pwm_val = SERVO_OCR_MIN + ((uint32_t) degrees * (SERVO_OCR_MAX-SERVO_OCR_MIN)) / 180;
 105               		.loc 1 81 0
 106 005a 262F      		mov r18,r22
 107 005c 30E0      		ldi r19,0
 108 005e A0ED      		ldi r26,lo8(-48)
 109 0060 B7E0      		ldi r27,lo8(7)
 110 0062 0E94 0000 		call __umulhisi3
 111               	.LVL14:
 112 0066 24EB      		ldi r18,lo8(-76)
 113 0068 30E0      		ldi r19,0
 114 006a 40E0      		ldi r20,0
 115 006c 50E0      		ldi r21,0
 116               	.LVL15:
 117 006e 0E94 0000 		call __udivmodsi4
 118 0072 CA01      		movw r24,r20
 119 0074 B901      		movw r22,r18
 120 0076 6C50      		subi r22,12
 121 0078 7E4F      		sbci r23,-2
 122 007a 8F4F      		sbci r24,-1
 123 007c 9F4F      		sbci r25,-1
  82:pwm.c         **** 		register_16_write(servo2, pwm_val);
 124               		.loc 1 82 0
 125 007e 8AE8      		ldi r24,lo8(-118)
 126 0080 90E0      		ldi r25,0
 127               	.LVL16:
 128 0082 00C0      		rjmp .L10
 129               	.LVL17:
 130               	.L8:
  83:pwm.c         **** 	}
  84:pwm.c         **** 	
  85:pwm.c         **** 	else if(servo_num == SERVO3)
 131               		.loc 1 85 0
 132 0084 8330      		cpi r24,lo8(3)
 133 0086 01F4      		brne .L6
 134               	.LVL18:
  86:pwm.c         **** 	{
  87:pwm.c         **** 		pwm_val = SERVO_OCR_MIN + ((uint32_t) degrees * (SERVO_OCR_MAX-SERVO_OCR_MIN)) / 180;
 135               		.loc 1 87 0
 136 0088 262F      		mov r18,r22
 137 008a 30E0      		ldi r19,0
 138 008c A0ED      		ldi r26,lo8(-48)
 139 008e B7E0      		ldi r27,lo8(7)
 140 0090 0E94 0000 		call __umulhisi3
 141               	.LVL19:
 142 0094 24EB      		ldi r18,lo8(-76)
 143 0096 30E0      		ldi r19,0
 144 0098 40E0      		ldi r20,0
 145 009a 50E0      		ldi r21,0
 146               	.LVL20:
 147 009c 0E94 0000 		call __udivmodsi4
 148 00a0 CA01      		movw r24,r20
 149 00a2 B901      		movw r22,r18
 150 00a4 6C50      		subi r22,12
 151 00a6 7E4F      		sbci r23,-2
 152 00a8 8F4F      		sbci r24,-1
 153 00aa 9F4F      		sbci r25,-1
  88:pwm.c         **** 		register_16_write(servo3, pwm_val);
 154               		.loc 1 88 0
 155 00ac 8CE8      		ldi r24,lo8(-116)
 156 00ae 90E0      		ldi r25,0
 157               	.LVL21:
 158               	.L10:
 159 00b0 0C94 0000 		jmp register_16_write
 160               	.LVL22:
 161               	.L6:
 162 00b4 0895      		ret
 163               		.cfi_endproc
 164               	.LFE7:
 166               	.global	timer1_init
 168               	timer1_init:
 169               	.LFB8:
  89:pwm.c         **** 	}
  90:pwm.c         **** /*
  91:pwm.c         **** 	else if(servo_num == SERVO4)
  92:pwm.c         **** 		pwm_val = 
  93:pwm.c         **** 		*servo4 = pwm_val
  94:pwm.c         **** */
  95:pwm.c         **** }
  96:pwm.c         **** 
  97:pwm.c         **** /**
  98:pwm.c         ****  * Initialisation for 16-bit Timer1
  99:pwm.c         ****  */
 100:pwm.c         **** void timer1_init(void)
 101:pwm.c         **** {
 170               		.loc 1 101 0
 171               		.cfi_startproc
 172               	/* prologue: function */
 173               	/* frame size = 0 */
 174               	/* stack size = 0 */
 175               	.L__stack_usage = 0
 102:pwm.c         **** 	//Phase correct mode
 103:pwm.c         **** 	icr1_temp = CLOCK_FQ / (2 * PRESCALER_VAL * SERVO_PWM_FREQ);
 176               		.loc 1 103 0
 177 00b6 80E2      		ldi r24,lo8(32)
 178 00b8 9EE4      		ldi r25,lo8(78)
 179 00ba A0E0      		ldi r26,0
 180 00bc B0E0      		ldi r27,0
 181 00be 8093 0000 		sts icr1_temp,r24
 182 00c2 9093 0000 		sts icr1_temp+1,r25
 183 00c6 A093 0000 		sts icr1_temp+2,r26
 184 00ca B093 0000 		sts icr1_temp+3,r27
 104:pwm.c         **** 
 105:pwm.c         **** 	TCCR1A |= (1 << WGM11);
 185               		.loc 1 105 0
 186 00ce E0E8      		ldi r30,lo8(-128)
 187 00d0 F0E0      		ldi r31,0
 188 00d2 8081      		ld r24,Z
 189 00d4 8260      		ori r24,lo8(2)
 190 00d6 8083      		st Z,r24
 106:pwm.c         **** 	TCCR1B |= (1 << WGM13);
 191               		.loc 1 106 0
 192 00d8 E1E8      		ldi r30,lo8(-127)
 193 00da F0E0      		ldi r31,0
 194 00dc 8081      		ld r24,Z
 195 00de 8061      		ori r24,lo8(16)
 196 00e0 8083      		st Z,r24
 107:pwm.c         **** 	TCCR1B |= (1 << CS11); //prescaler = 8
 197               		.loc 1 107 0
 198 00e2 8081      		ld r24,Z
 199 00e4 8260      		ori r24,lo8(2)
 200 00e6 8083      		st Z,r24
 108:pwm.c         **** 
 109:pwm.c         **** 	register_16_write(&ICR1, icr1_temp);
 201               		.loc 1 109 0
 202 00e8 6091 0000 		lds r22,icr1_temp
 203 00ec 7091 0000 		lds r23,icr1_temp+1
 204 00f0 86E8      		ldi r24,lo8(-122)
 205 00f2 90E0      		ldi r25,0
 206 00f4 0C94 0000 		jmp register_16_write
 207               	.LVL23:
 208               		.cfi_endproc
 209               	.LFE8:
 211               	.global	timer3_init
 213               	timer3_init:
 214               	.LFB9:
 110:pwm.c         **** 	//ICR1H = icr1_temp >> 8;
 111:pwm.c         **** 	//ICR1L = icr1_temp;
 112:pwm.c         **** }
 113:pwm.c         **** 
 114:pwm.c         **** /**
 115:pwm.c         ****  * Initialisation for 16-bit Timer3
 116:pwm.c         ****  */
 117:pwm.c         **** void timer3_init(void)
 118:pwm.c         **** {
 215               		.loc 1 118 0
 216               		.cfi_startproc
 217               	/* prologue: function */
 218               	/* frame size = 0 */
 219               	/* stack size = 0 */
 220               	.L__stack_usage = 0
 119:pwm.c         **** 	//Phase correct mode, timer 3
 120:pwm.c         **** 	icr3_temp = CLOCK_FQ / (2 * PRESCALER_VAL * BRUSHLESS_PWM_FREQ);
 221               		.loc 1 120 0
 222 00f8 80E2      		ldi r24,lo8(32)
 223 00fa 9EE4      		ldi r25,lo8(78)
 224 00fc A0E0      		ldi r26,0
 225 00fe B0E0      		ldi r27,0
 226 0100 8093 0000 		sts icr3_temp,r24
 227 0104 9093 0000 		sts icr3_temp+1,r25
 228 0108 A093 0000 		sts icr3_temp+2,r26
 229 010c B093 0000 		sts icr3_temp+3,r27
 121:pwm.c         **** 
 122:pwm.c         **** 	TCCR3A |= (1 << WGM31);
 230               		.loc 1 122 0
 231 0110 E0E9      		ldi r30,lo8(-112)
 232 0112 F0E0      		ldi r31,0
 233 0114 8081      		ld r24,Z
 234 0116 8260      		ori r24,lo8(2)
 235 0118 8083      		st Z,r24
 123:pwm.c         **** 	TCCR3B |= (1 << WGM33);
 236               		.loc 1 123 0
 237 011a E1E9      		ldi r30,lo8(-111)
 238 011c F0E0      		ldi r31,0
 239 011e 8081      		ld r24,Z
 240 0120 8061      		ori r24,lo8(16)
 241 0122 8083      		st Z,r24
 124:pwm.c         **** 	TCCR3B |= (1 << CS31); //prescaler = 8
 242               		.loc 1 124 0
 243 0124 8081      		ld r24,Z
 244 0126 8260      		ori r24,lo8(2)
 245 0128 8083      		st Z,r24
 125:pwm.c         **** 
 126:pwm.c         **** 	register_16_write(&ICR3, icr3_temp);
 246               		.loc 1 126 0
 247 012a 6091 0000 		lds r22,icr3_temp
 248 012e 7091 0000 		lds r23,icr3_temp+1
 249 0132 86E9      		ldi r24,lo8(-106)
 250 0134 90E0      		ldi r25,0
 251 0136 0C94 0000 		jmp register_16_write
 252               	.LVL24:
 253               		.cfi_endproc
 254               	.LFE9:
 256               	.global	pwm_init
 258               	pwm_init:
 259               	.LFB10:
 127:pwm.c         **** 	//ICR3H = icr3_temp >> 8;
 128:pwm.c         **** 	//ICR3L = icr3_temp;
 129:pwm.c         **** }
 130:pwm.c         **** 
 131:pwm.c         **** void pwm_init(void)
 132:pwm.c         **** {
 260               		.loc 1 132 0
 261               		.cfi_startproc
 262               	/* prologue: function */
 263               	/* frame size = 0 */
 264               	/* stack size = 0 */
 265               	.L__stack_usage = 0
 133:pwm.c         **** 
 134:pwm.c         **** /**********************************************************
 135:pwm.c         ****  *  			OC2A pin
 136:pwm.c         ****  * 		-TCCR2A register-
 137:pwm.c         ****  * FOC2A  WGM20  COM2A1  COM2A0  WGM21  CS22  CS21  CS20
 138:pwm.c         ****  *  0		1		1		0	   1	  1		0	 0
 139:pwm.c         ****  *
 140:pwm.c         ****  **********************************************************/
 141:pwm.c         **** 	//fastpwm on OC2A pin
 142:pwm.c         **** 	DDRB |= (1 << PB4);
 266               		.loc 1 142 0
 267 013a 249A      		sbi 0x4,4
 143:pwm.c         **** 
 144:pwm.c         **** 	TCCR2A = 0x6C;
 268               		.loc 1 144 0
 269 013c 8CE6      		ldi r24,lo8(108)
 270 013e 8093 B000 		sts 176,r24
 145:pwm.c         **** 	OCR2A = 0;
 271               		.loc 1 145 0
 272 0142 1092 B300 		sts 179,__zero_reg__
 146:pwm.c         **** /******************************************************************/
 147:pwm.c         **** 
 148:pwm.c         **** /***************OC1A***********************************************/
 149:pwm.c         **** 	//fast pwm on OC1A pin (PB2 - PWM2)
 150:pwm.c         **** 	DDRB |= (1 << PB5); //enable pin as output
 273               		.loc 1 150 0
 274 0146 259A      		sbi 0x4,5
 151:pwm.c         **** 	OCR1AH = 0;
 275               		.loc 1 151 0
 276 0148 1092 8900 		sts 137,__zero_reg__
 152:pwm.c         **** 	OCR1AL = 0;
 277               		.loc 1 152 0
 278 014c 1092 8800 		sts 136,__zero_reg__
 153:pwm.c         **** 
 154:pwm.c         **** //	TCCR1A |= (1 << COM1A1); //clear on compare match when up counting
 155:pwm.c         **** //	TCCR1A &= ~(1 << COM1A0);
 156:pwm.c         **** 	TCCR1A |= (1 << COM1A1);
 279               		.loc 1 156 0
 280 0150 E0E8      		ldi r30,lo8(-128)
 281 0152 F0E0      		ldi r31,0
 282 0154 8081      		ld r24,Z
 283 0156 8068      		ori r24,lo8(-128)
 284 0158 8083      		st Z,r24
 157:pwm.c         **** 
 158:pwm.c         **** /*********************************************************************/
 159:pwm.c         **** /************** OC1B **************************************************/
 160:pwm.c         **** 	DDRB |= (1 << PB6);
 285               		.loc 1 160 0
 286 015a 269A      		sbi 0x4,6
 161:pwm.c         **** 	OCR1BH = 0;
 287               		.loc 1 161 0
 288 015c 1092 8B00 		sts 139,__zero_reg__
 162:pwm.c         **** 	OCR1BL = 0;
 289               		.loc 1 162 0
 290 0160 1092 8A00 		sts 138,__zero_reg__
 163:pwm.c         **** 
 164:pwm.c         **** 	TCCR1A |= (1 << COM1B1);
 291               		.loc 1 164 0
 292 0164 8081      		ld r24,Z
 293 0166 8062      		ori r24,lo8(32)
 294 0168 8083      		st Z,r24
 165:pwm.c         **** //	TCCR1A |= (1 << COM1B1);
 166:pwm.c         **** //	TCCR1A &= ~(1 << COM1B0);
 167:pwm.c         **** 
 168:pwm.c         **** /*********************************************************************/
 169:pwm.c         **** /************* OC1C **************************************************/
 170:pwm.c         **** 	DDRB |= (1 << PB7);
 295               		.loc 1 170 0
 296 016a 279A      		sbi 0x4,7
 171:pwm.c         **** 	OCR1CH = 0;
 297               		.loc 1 171 0
 298 016c 1092 8D00 		sts 141,__zero_reg__
 172:pwm.c         **** 	OCR1CL = 0;
 299               		.loc 1 172 0
 300 0170 1092 8C00 		sts 140,__zero_reg__
 173:pwm.c         **** 
 174:pwm.c         **** 	TCCR1A |= (1 << COM1C1);
 301               		.loc 1 174 0
 302 0174 8081      		ld r24,Z
 303 0176 8860      		ori r24,lo8(8)
 304 0178 8083      		st Z,r24
 175:pwm.c         **** //	TCCR1A |= (1 << COM1C1);
 176:pwm.c         **** //	TCCR1A &= ~(1 << COM1C0);
 177:pwm.c         **** 
 178:pwm.c         **** /*********************************************************************/
 179:pwm.c         **** 
 180:pwm.c         **** /*********OC3C - PBR1*************************************************/
 181:pwm.c         **** //OC3C
 182:pwm.c         **** 	DDRE |= (1 << PE5);
 305               		.loc 1 182 0
 306 017a 6D9A      		sbi 0xd,5
 183:pwm.c         **** 	TCCR3A |= (1 << COM3C1);
 307               		.loc 1 183 0
 308 017c E0E9      		ldi r30,lo8(-112)
 309 017e F0E0      		ldi r31,0
 310 0180 8081      		ld r24,Z
 311 0182 8860      		ori r24,lo8(8)
 312 0184 8083      		st Z,r24
 184:pwm.c         **** 
 185:pwm.c         **** 	OCR3CH = 0;
 313               		.loc 1 185 0
 314 0186 1092 9D00 		sts 157,__zero_reg__
 186:pwm.c         **** 	OCR3CL = 0;
 315               		.loc 1 186 0
 316 018a 1092 9C00 		sts 156,__zero_reg__
 187:pwm.c         **** /********OC3B - PBR2**************************************************/
 188:pwm.c         **** 	DDRE |= (1 << PE4);
 317               		.loc 1 188 0
 318 018e 6C9A      		sbi 0xd,4
 189:pwm.c         **** 	TCCR3A |= (1 << COM3B1);
 319               		.loc 1 189 0
 320 0190 8081      		ld r24,Z
 321 0192 8062      		ori r24,lo8(32)
 322 0194 8083      		st Z,r24
 190:pwm.c         **** 
 191:pwm.c         **** 	OCR3BH = 0;
 323               		.loc 1 191 0
 324 0196 1092 9B00 		sts 155,__zero_reg__
 192:pwm.c         **** 	OCR3BL = 0;
 325               		.loc 1 192 0
 326 019a 1092 9A00 		sts 154,__zero_reg__
 327 019e 0895      		ret
 328               		.cfi_endproc
 329               	.LFE10:
 331               		.local	icr1_temp
 332               		.comm	icr1_temp,4,1
 333               		.local	icr3_temp
 334               		.comm	icr3_temp,4,1
 335               	.Letext0:
 336               		.file 2 "/usr/lib/avr/include/stdint.h"
 337               		.file 3 "register.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 pwm.c
     /tmp/ccFOqvev.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccFOqvev.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccFOqvev.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccFOqvev.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccFOqvev.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccFOqvev.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccFOqvev.s:13     .text:0000000000000000 pbr_pwm_set
     /tmp/ccFOqvev.s:62     .text:0000000000000028 servo_pwm_set
     /tmp/ccFOqvev.s:168    .text:00000000000000b6 timer1_init
                             .bss:0000000000000000 icr1_temp
     /tmp/ccFOqvev.s:213    .text:00000000000000f8 timer3_init
     /tmp/ccFOqvev.s:332    .bss:0000000000000004 icr3_temp
     /tmp/ccFOqvev.s:258    .text:000000000000013a pwm_init

UNDEFINED SYMBOLS
register_16_write
__umulhisi3
__udivmodsi4
__do_clear_bss
